<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Linux on sorgDream&#39;s Blog</title>
    <link>https://blog.sorgdream.com/tags/linux/</link>
    <description>Recent content in Linux on sorgDream&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>sorgDream - [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
    <lastBuildDate>Wed, 31 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.sorgdream.com/tags/linux/index.xml" rel="self" type="application/rss+xml" /><icon>https://blog.sorgdream.com/avatar.jpg</icon>
    
    
    <item>
      <title>Pigo实现人脸识别</title>
      <link>https://blog.sorgdream.com/posts/pigo-face/</link>
      <pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/pigo-face/</guid>
      <description><![CDATA[<p>最近学Go的时候发现个好玩的库，可以识别图片中的人像，并且提供二进制发行版</p>
<h2 id="使用">使用</h2>
<p>从<a href="https://github.com/esimov/pigo/releases">Releases</a>处下载对应系统的二进制</p>
<p>下载<a href="https://github.com/esimov/pigo/blob/master/cascade/facefinder">facefinder</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./pigo -in input.png -out out.png &lt; input/source.jpg -cf<span style="color:#f92672">=</span>/path/to/cascade
</span></span></code></pre></div><p>即可识别<code>input.png</code>，并输出<code>output.png</code></p>
<h2 id="预览图">预览图</h2>
<p><img src="https://user-images.githubusercontent.com/883386/40916662-2fbbae1a-6809-11e8-8afd-d4ed40c7d4e9.png" alt="Rectangle face marker"></p>
<h2 id="识别视频">识别视频</h2>
<p>因为Pigo默认只能识别图片，想让它识别整个视频的话只能将视频切成图片进行逐一识别，毕竟视频也是图片组成的</p>
<h3 id="下载视频">下载视频</h3>
<p>B站不提供直接的视频下载方式，试了几个网站的下载工具发现要不就是不能用，要么分辨率太低，所以这里使用自带的缓存功能</p>
<p>到手机<code>/storage/emulated/0/Android/data/com.bilibili.app.in/download/</code>目录下，会发现一串以数字命名的文件夹，进入其子目录，会看到一个以数字命名的文件夹，和两个<code>.xml</code>,<code>.json</code>结尾的文件</p>
<p>进入数字文件夹，需要的两个文件出现了，<code>audio.m4s</code>为音频文件，<code>video.m4s</code>为视频文件，将音频拓展名重命名为<code>*.mp3</code>，视频为<code>*.mp4</code>，移动到任意剪辑软件能读取的目录</p>
<p>将两个文件导入剪辑软件，将视频和音频同步拖到对应轨道，导出即可</p>
<h3 id="切割视频">切割视频</h3>
<p>这里博主使用的工具是<a href="https://ffmpeg.org/">FFmpeg</a></p>
<p>最好创建一个专门的文件夹存放输出的图片</p>
<blockquote>
<p>A complete, cross-platform solution to record, convert and stream audio and video.</p>
</blockquote>
<p>使用<code>ffmpeg -i lockHand.mp4 -r 24 ./lockHand/output%d.png </code>以每秒24张图片分解视频</p>
<p>-i: 指定分割的视频</p>
<p>-r: 设置帧率，默认为25</p>
<p><code>output%d.png</code>中<code>%d</code>是占位符，ffmpeg将以1.2.3&hellip;的顺序命名输出文件</p>
<p>完成后，到<code>lockHand</code>目录下即可看到输出的图片</p>
<h3 id="批量识别">批量识别</h3>
<p>一个18秒，24帧的视频就需要432张图片，这么多图片难不成要我们手动一张张识别？估计得识别到地球爆炸;像我这么懒的人肯定不会这么做，我决定用一个脚本来替我完成这项艰巨的任务</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span><span style="color:#f92672">((</span>i<span style="color:#f92672">=</span>1;i&lt;<span style="color:#f92672">=</span>422;i++<span style="color:#f92672">))</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  ./pigo -in ./lockHand/output$i.png -out ./outHand/out$i.png -cf ./facefinder
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;处理次数:&#34;</span>$i
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>很简单的脚本，其中<code>442</code>为生成的源图片数量，<code>./lockHand/output$i.png</code>需要改为源图片文件文件夹，<code>$i</code>和<code>%d</code>差不多，产出目录同上</p>
<p>等待脚本完成，到<code>./lockHand</code>即可看到产出图片</p>
<h3 id="合并视频">合并视频</h3>
<p>同样使用FFmpeg</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ffmpeg -r <span style="color:#ae81ff">24</span> -f image2 -i ./outHand/out%d.png output.mp4  <span style="color:#75715e">##合成</span>
</span></span></code></pre></div><p>参数代表的含义与分割视频一致</p>
<p>激动人心的时刻到了，点击output.mp4即可看到识别的红框</p>
<h2 id="演示视频">演示视频</h2>
<p><a href="https://www.bilibili.com/video/BV1uU421Z7LU/?share_source=copy_web&amp;vd_source=1345dad103258a05d7c3f69f300fc342">控头大师，但Pigo实现</a></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Frp自建内网穿透</title>
      <link>https://blog.sorgdream.com/posts/nat-traversal/</link>
      <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/nat-traversal/</guid>
      <description><![CDATA[<p>这几天一直在折腾内网穿透的事，原因很简单，服务器的ROM不够大，又没钱升级配置，又拍云的免费OSS不备案无法绑定域名，免费的内网穿透速率太小了，更别提还有流量限制</p>
<p>想了想貌似只能自己建一个了，刚好手里有吃灰的Orangepi Zeor3，买的时候配了张128G的TF卡，虽然速度一般，但对于我来说是绰绰有余了</p>
<h2 id="frp">frp</h2>
<p>提到内网穿透，想到的肯定是大名顶顶的<strong>frp</strong>，目前在Github上已有76.3K starred</p>
<p>网上的很多文章大多是教你用基于frp的一键配置脚本，但试了几个发现都没用后决定自己尝试</p>
<h3 id="安装使用">安装&amp;使用</h3>
<p>frp的安装很简单，参照<a href="https://gofrp.org/zh-cn/">文档</a>的教程</p>
<ol>
<li>
<p>到<a href="https://github.com/fatedier/frp/releases/tag/v0.53.2">Releases</a>处下载适合的架构/系统的压缩包，解压到任意目录</p>
</li>
<li>
<p>使用<code>./frps -c ./frps.toml</code>启动服务端</p>
</li>
<li>
<p>使用<code>./frpc -c ./frpc.toml</code>启动客户端</p>
</li>
</ol>
<h3 id="使用-systemd-开机自启动">使用 systemd 开机自启动</h3>
<p>如果断开ssh连接，frp服务也会断开;可以将它设置为开机自启</p>
<ol>
<li>(如果尚未安装)使用<code>apt install systemd </code>安装，其他发行版使用其包管理器即可</li>
<li>编辑<code>/etc/systemd/system/frps.service</code>创建frp服务配置，写入以下内容</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-service" data-lang="service"><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 服务名称，可自定义</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description </span><span style="color:#f92672">=</span><span style="color:#e6db74"> frp server</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">After </span><span style="color:#f92672">=</span><span style="color:#e6db74"> network.target syslog.target</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Wants </span><span style="color:#f92672">=</span><span style="color:#e6db74"> network.target</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type </span><span style="color:#f92672">=</span><span style="color:#e6db74"> simple</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 启动frps的命令，需修改为您的frps的安装路径</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ExecStart </span><span style="color:#f92672">=</span><span style="color:#e6db74"> /path/to/frps -c /path/to/frps.toml</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Install]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">WantedBy </span><span style="color:#f92672">=</span><span style="color:#e6db74"> multi-user.target</span>
</span></span></code></pre></div><p>3.管理命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 启动frp</span>
</span></span><span style="display:flex;"><span>sudo systemctl start frps
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 停止frp</span>
</span></span><span style="display:flex;"><span>sudo systemctl stop frps
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 重启frp</span>
</span></span><span style="display:flex;"><span>sudo systemctl restart frps
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看frp状态</span>
</span></span><span style="display:flex;"><span>sudo systemctl status frps
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 开机自启动</span>
</span></span><span style="display:flex;"><span>sudo systemctl enable frps
</span></span></code></pre></div><p>之后的frpc也是大同小异，只需要更改名字和位置即可</p>
<h3 id="配置">配置</h3>
<p>重点来了，frp有两个配置，一个<code>frps.toml</code>用于服务端，一个<code>frpc.toml</code>用于客户端</p>
<ol>
<li>配置frps.toml</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#a6e22e">bindPort</span> = <span style="color:#ae81ff">7000</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">vhostHTTPPort</span> = <span style="color:#ae81ff">7890</span>
</span></span></code></pre></div><p><code>bindPort</code>不用管，<code>vhostHTTPPort</code>为连接的端口，默认为8080,但端口被我的评论占用了，所以改成7890</p>
<p>如像我这样，配置完后可以通过<code>http://www.yourdomain.com:7890</code>访问</p>
<ol start="2">
<li>配置frpc.toml</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#a6e22e">serverAddr</span> = <span style="color:#e6db74">&#34;x.x.x.x&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">serverPort</span> = <span style="color:#ae81ff">7000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[[<span style="color:#a6e22e">proxies</span>]]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;image-hosting&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">type</span> = <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">localIP</span> = <span style="color:#e6db74">&#34;192.168.xx.xxx&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">localPort</span> = <span style="color:#ae81ff">7890</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">customDomains</span> = [<span style="color:#e6db74">&#34;www.example.com&#34;</span>]
</span></span></code></pre></div><p>serverAddr: 服务器IP</p>
<p>name: 取一个好记的名字</p>
<p>type: 因为要搭建网站所以选择http</p>
<p>localIP: 本机IP</p>
<p>localPort: 内网服务部署端口</p>
<p>customDomains: 绑定的域名</p>
<p>PS: 原本还有一个<code>remotePort = 6000</code>配置，看到文档没有就删了，实测没有影响</p>
<p>将和 <a href="https://www.example.com">www.example.com</a> 的域名 A 记录解析到服务器的 IP 地址<code>x.x.x.x</code></p>
<p>访问<code>www.example.com:7890</code>即可访问内网机器上的<code>7890</code>服务</p>
<h3 id="nginx配置">Nginx配置</h3>
<p>不得不说Nginx真是好用，配置方便，功能强大; 配置完frp,接下来就是nginx</p>
<p>因为上面只进行了内网穿透，内网的机器还需要配置nginx来显示网站</p>
<ol>
<li>还没有安装的在等什么，使用<code>apt install nginx</code>安装nginx</li>
<li>在<code>etc/nginx/conf.d/</code>文件夹内添加配置文件，文件名随意，以<code>.conf</code>作为拓展名</li>
<li>增添配置，以下为我的配置</li>
</ol>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 7890;
    server_name www.example.com;
    root /home/image-hosting;

    fancyindex on;            
    fancyindex_exact_size off; 
    fancyindex_localtime on; 
    fancyindex_name_length 255; 
    fancyindex_time_format &#34;%Y-%m-%d %H:%M:%S&#34;;

    location / {
    }
}
</code></pre><p>listen: 监听7890端口</p>
<p>server_name: 绑定的域名</p>
<p>root: 网站所在文件夹</p>
<p>以下配置开启文件引索，若无需求可以忽略</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf"> fancyindex on;            
    fancyindex_exact_size on; 
    fancyindex_localtime on; 
    fancyindex_name_length 255; 
    fancyindex_time_format &#34;%Y-%m-%d %H:%M:%S&#34;;
</code></pre><p>再一次尝试访问<code>www.example.com:7890</code>查看是否正常显示</p>
<h4 id="去端口访问">去端口访问</h4>
<p>整天带端口访问太丑了，可以使用nginx的反向代理功能解决，原理就是在服务器上套层nginx，将<code>www.example.com</code>反向代理至<code>www.example.com:7890</code></p>
<p>以下是我的配置</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name www.example.com; # 设置的域名
    location / {
             proxy_pass  http://www.example.com:7890; # 反向代理至8080端口
    }
}
</code></pre><p>配置完尝试使用<code>www.example.com</code>访问</p>
<h3 id="https">HTTPS</h3>
<p>虽然现在已经可以较为优雅地访问了，但因为缺少ssl证书，每次访问都给我警告</p>
<p>frp支持为本地 HTTP 服务启用 HTTPS，但需要自行下载证书到内网机器，而且无法使用像certbot这样的工具，所以我选择在服务器的Nginx配置证书</p>
<p>关于如何获取证书，我的<a href="https://blog.inuya.ltd/posts/winter/">上上篇文章</a>已经讲的很清楚了，下面是我的配置</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name img.inuya.ltd; # 设置的域名
    location / {
             proxy_pass  http://img.inuya.ltd:7890; # 反向代理至7890端口
    }
}

server {
    listen 443;
    server_name img.inuya.ltd;
    ssl_certificate /etc/letsencrypt/live/img.inuya.ltd/fullchain.pem;  # 配置证书
    ssl_certificate_key /etc/letsencrypt/live/img.inuya.ltd/privkey.pem;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    # 表示使用的加密套件的类型。
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 表示使用的TLS协议的类型。
    ssl_prefer_server_ciphers on;
    location / {
            proxy_pass http://img.inuya.ltd:7890;
    }
}
</code></pre><h2 id="图床">图床</h2>
<p>搞定了内网穿透，但怎么把图片显示出来呢，1P面板有个图床的docker镜像，用了下感觉很一般，不如自己建一个</p>
<p>因为没学过前端，所以只能边学边建，写出来的东西也是漏洞百出，但最起码能用了</p>
<h3 id="文件引索">文件引索</h3>
<p>原本是想写一个文件引索，看了几篇文章都是无从下手，偶然看到一篇关闭<code>Apache</code>默认文件引索功能的文章，想到Nginx是否也有这个功能，找了一下还真有，只不过需要手动开启</p>
<p>在内网机器的nginx配置中添加以下内容</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen  80;
    server_name 192.168.31.112;
    root /home/image-hosting;
    autoindex on;    	#启用或禁用目录列表输出
    autoindex_format html； #设置目录列表的格式
    autoindex_localtime on;  #指定目录列表中的时间是否应以本地时区或 UTC 输出
    autoindex_exact_size off;  #是否应在目录列表中输出确切的文件大小
}
</code></pre><p>输入一个网站目录，看是否能浏览文件</p>
<h3 id="嵌入引索">嵌入引索</h3>
<p>因索有了，但我不想手动一个个翻图片，于是将它嵌入到了我的主页</p>
<p>在代码中添加<code>&lt;iframe&gt;</code>标签即可嵌入一个网页，因为我想显示<code>Images</code>目录的引索，所以src中填入了<code>images/</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;div-pic&#34;</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">iframe</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;images/&#34;</span> <span style="color:#a6e22e">width</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;100%&#34;</span> <span style="color:#a6e22e">height</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;800px&#34;</span> <span style="color:#a6e22e">scrolling</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;auto&#34;</span> <span style="color:#a6e22e">framespacing</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">allowfullscreen</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;true&#34;</span>&gt; &lt;/<span style="color:#f92672">iframe</span>&gt;   
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">div</span>&gt;
</span></span></code></pre></div><p>如果想要更换嵌入的网站，只需要修改<code>src=&quot;&quot;</code> 里的内容为目标网址即可</p>
<h4 id="美化引索">美化引索</h4>
<p>但这样还有一个问题，默认的引索在网站的背景是透明的，导致看不清文件名，CSS添加的背景太亮了，又偶然看见一篇用第三方模块来美化的文章</p>
<p><!-- raw HTML omitted -->使用<code>fancyindex</code>模块替代默认的引索，来达到美化的效果</p>
<ol>
<li><code>apt install libnginx-mod-http-fancyindex</code>安装模块</li>
<li>修改/创建<code>/etc/nginx/conf.d/</code>下的配置，添加以下内容以开启引索</li>
</ol>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name 192.168.31.112;
    root /home/image-hosting;

    fancyindex on;            
    fancyindex_exact_size off; 
    fancyindex_localtime on; 
    fancyindex_name_length 255; 
    fancyindex_time_format &#34;%Y-%m-%d %H:%M:%S&#34;;

    location / {
    }
}
</code></pre><p>返回网站，刷新即可看到新样式</p>
<p>fancyindex还有许多主题可选，如<a href="https://github.com/Naereen/Nginx-Fancyindex-Theme">Nginx-Fancyindex-Theme</a>和<a href="https://github.com/alehaa/nginx-fancyindex-flat-theme">nginx-fancyindex-flat-theme</a></p>
<p>也可以用<code>fancyindex</code>加<code>theme</code>关键字在Guthub搜索其他主题</p>
<h2 id="补充">补充</h2>
<p>其实内网穿透这个想法很早就有了，但一直搁置到现在;未来可能还会把Twikoo评论也放到开发板上，还是要看评论的人多不多</p>
<p>最后祝大家玩得开心</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_autoindex_module.html">Module ngx_http_autoindex_module</a></li>
<li><a href="https://gofrp.org/zh-cn/">frp</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Arch下的Kde配置</title>
      <link>https://blog.sorgdream.com/posts/arch-kde/</link>
      <pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/arch-kde/</guid>
      <description><![CDATA[<p>2024年的第一篇文章，祝大家新年快乐(虽然有点迟了)</p>
<p>这段时间重装了6次Arch，1次Debian Testing，几乎将主流桌面体验完了，血与泪的教训，wayland目前还不成熟，高分屏还得老老实实用x11</p>
<h2 id="起因">起因</h2>
<p>逛B站时偶然看到了有人发<a href="https://www.bilibili.com/read/cv22707313/">Hyprland的配置</a>，再看我的Kde瞬间就不香了</p>
<p>拿出我珍藏多年的Arch Live CD ，F12选择U盘启动，在经过一系列分区，生成fstab，引导后，成功来到了熟悉的tty界面，接下来照着B站的教程，开始安装Hyprland</p>
<h2 id="hyprland">Hyprland</h2>
<blockquote>
<p>Hyprland is a highly customizable dynamic tiling Wayland compositor that doesn&rsquo;t sacrifice on its looks.</p>
</blockquote>
<blockquote>
<p>Hyprland 是一款高度可定制的动态平铺 Wayland 合成器，不会牺牲其外观。</p>
</blockquote>
<h3 id="安装">安装</h3>
<ol>
<li>首先安装Wayland</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pacman -S xorg-xwayland qt5-wayland qt6-wayland glfw-wayland
</span></span></code></pre></div><ol start="2">
<li>安装Hyprland</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>paru -S hyprland-bin
</span></span></code></pre></div><ol start="3">
<li>复制配置文件</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -pv ~/.config/hypr
</span></span><span style="display:flex;"><span>sudo cp /usr/share/hyprland/hyprland.conf ~/.config/hypr/
</span></span></code></pre></div><ol start="4">
<li>Hyprland启动</li>
</ol>
<p>通过编辑<code>~/.bash_profile</code>启动(不使用显示管理器)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 启动 wayland 桌面前设置一些环境变量</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> set_wayland_env
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	cd <span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 设置语言环境为中文</span>
</span></span><span style="display:flex;"><span>	export LANG<span style="color:#f92672">=</span>zh_CN.UTF-8
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 解决QT程序缩放问题</span>
</span></span><span style="display:flex;"><span>	export QT_AUTO_SCREEN_SCALE_FACTOR<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># QT使用wayland和gtk</span>
</span></span><span style="display:flex;"><span>	export QT_QPA_PLATFORM<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;wayland;xcb&#34;</span>
</span></span><span style="display:flex;"><span>	export QT_WAYLAND_DISABLE_WINDOWDECORATION<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 使用qt5ct软件配置QT程序外观</span>
</span></span><span style="display:flex;"><span>	export QT_QPA_PLATFORMTHEME<span style="color:#f92672">=</span>qt5ct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 一些游戏使用wayland</span>
</span></span><span style="display:flex;"><span>	export SDL_VIDEODRIVER<span style="color:#f92672">=</span>wayland
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 解决java程序启动黑屏错误</span>
</span></span><span style="display:flex;"><span>	export _JAVA_AWT_WM_NONEREPARENTING<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># GTK后端为 wayland和x11,优先wayland</span>
</span></span><span style="display:flex;"><span>	export GDK_BACKEND<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;wayland,x11&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 命令行输入这个命令启动hyprland,可以自定义</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> start_hyprland
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	set_wayland_env
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	export XDG_SESSION_TYPE<span style="color:#f92672">=</span>wayland
</span></span><span style="display:flex;"><span>	export XDG_SESSION_DESKTOP<span style="color:#f92672">=</span>Hyprland
</span></span><span style="display:flex;"><span>	export XDG_CURRENT_DESKTOP<span style="color:#f92672">=</span>Hyprland
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 启动 Hyprland程序</span>
</span></span><span style="display:flex;"><span>	exec Hyprland
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>重启或直接<code>source ~/.bash_profile</code>使配置生效，输入<code>start_hyprland</code>启动</p>
<h3 id="应用安装">应用安装</h3>
<p>刚进入桌面，你会发现什么也没有，先装个终端和中文字体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pacman -S kitty wqy-zenhei
</span></span></code></pre></div><p>使用快捷键<code>Super+Q</code>即可启动(Super键默认为WIN)</p>
<p>貌似一切都很完美，让我们装个QQ试逝</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>paru -S linuxqq
</span></span></code></pre></div><p>打开后你会发现字体变得很模糊，不止qq,其他程序在wayland缩放下的显示都不太好</p>
<h2 id="gnome">Gnome</h2>
<blockquote>
<p>GNOME originally an acronym for GNU Network Object Model Environment,is a free and open-source desktop environment for Linux and other Unix-like operating systems.</p>
</blockquote>
<blockquote>
<p>GNOME是一个完全由自由软件组成的桌面环境。它的目标操作系统是Linux，但是大部分的BSD系统亦支持GNOME。</p>
</blockquote>
<p>因为Hyprland的字体问题，我回到了一开始用的gnome;但因为使用wayland的原因，qq下的字体还是模糊，而且缩放有问题，200%会使字体和窗口过大，100%字又太小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gsettings set org.gnome.mutter experimental-features <span style="color:#e6db74">&#34;[&#39;scale-monitor-framebuffer&#39;]&#34;</span>
</span></span></code></pre></div><p>使用此命令开启分数缩放</p>
<p>缩放是解决了，但字体的问题依旧，目前没找到完美的解决方案，只能用<code>Tweaks</code>工具调整字体大小</p>
<h2 id="cinnamon">Cinnamon</h2>
<blockquote>
<p>Cinnamon, forked from GNOME Shell, is the &ldquo;shell&rdquo; of Cinnamon. It provides the user interface such as panels, hot corners, menus etc. The ui is written in JavaScript, while its core libraries are written in C.</p>
</blockquote>
<blockquote>
<p>Cinnamon是类Unix系统下的一个桌面环境。最初是GNOME Shell的一个派生版本，由Linux Mint开发，提供了相似于GNOME 2，易于使用的传统用户界面，从Cinnamon 2.0开始，成为独立的桌面环境。</p>
</blockquote>
<p>一个由Mint开发的桌面，也是Linux Mint的默认桌面</p>
<p>Cinnamon不同于前两个，使用的是x11，所以基本没有字体和缩放问题，而且桌面和发生版都很适合新手，Debian系的包也比较多</p>
<p>但我不是很喜欢Cinnamon的设计，所以没有使用它</p>
<h2 id="kde-plasma">KDE Plasma</h2>
<blockquote>
<p>Plasma is a graphical shell developed by KDE for Unix-like operating systems. Plasma is a standard desktop interface.</p>
</blockquote>
<blockquote>
<p>KDE 是一套由 Plasma 桌面环境、一系列的库、框架（KDE Frameworks）和一些应用组成的软件项目。</p>
</blockquote>
<p>目前在用的桌面，自定义程度很高，记录下配置过程</p>
<h3 id="汉化不完全">汉化不完全</h3>
<p>表现为设置/文件管理器一半中文一半英文</p>
<p>编辑<code>~/.config/plasma-localerc</code>将<code>LANG=h_CN</code>改为<code>LANG=zh_CN.UTF-8</code>，重启后即可解决</p>
<h3 id="系统代理">系统代理</h3>
<ol>
<li>
<p>手机代理设置-允许来自局域网连接，记录端口;在设置-网络设置-代理服务器中选择-使用手动指定的的代理服务器配置</p>
</li>
<li>
<p>手机任意终端<code>su</code>后使用<code>ifconfig</code>获取本机IP,填入代理设置</p>
</li>
<li>
<p>终端走代理</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export https_proxy<span style="color:#f92672">=</span>http://127.0.0.1:7890 http_proxy<span style="color:#f92672">=</span>http://127.0.0.1:7890 all_proxy<span style="color:#f92672">=</span>socks5://127.0.0.1:7891
</span></span></code></pre></div><p><code>7890</code>/<code>7891</code>为端口号，<code>127.0.0.1</code>为IP</p>
<h3 id="常用应用">常用应用</h3>
<h4 id="1-neovim">1. neovim</h4>
<p>使用<a href="https://github.com/ayamir/nvimdots">nvimdots</a>配置，另一选择<a href="https://github.com/NvChad/NvChad">NcChad</a></p>
<blockquote>
<p>LazyVim is a Neovim setup powered by 💤 lazy.nvim to make it easy to customize and extend your config. Rather than having to choose between starting from scratch or using a pre-made distro, LazyVim offers the best of both worlds - the flexibility to tweak your config as needed, along with the convenience of a pre-configured setup.</p>
</blockquote>
<h5 id="11-安装">1.1 安装</h5>
<ol>
<li>1.1.1 <strong>依赖</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></li>
</ol>
<ul>
<li>Neovim &gt;= 0.9.0 (needs to be built with LuaJIT)</li>
<li>Git &gt;= 2.19.0 (for partial clones support)</li>
<li>a Nerd Font (optional)</li>
<li>a C compiler for nvim-treesitter. See here</li>
</ul>
<ol start="2">
<li>1.1.2 安装</li>
</ol>
<p>克隆配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/LazyVim/starter ~/.config/nvim
</span></span></code></pre></div><p>nvim启动!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nvim
</span></span></code></pre></div><h5 id="12-nvim下的复制粘贴">1.2 nvim下的复制粘贴</h5>
<p><code>sudo pacman -S xclip</code>安装xclip后，使用<code>v</code>选中要复制的内容，<code>y</code>复制，<code>p</code>粘贴，<code>d</code>剪切</p>
<h4 id="2-neofetch">2. neofetch</h4>
<p>相信用过Linux的都听说过这个软件，它能显示系统Ascii art和硬件信息，可以通过修改<code>~/.config/neofetch/config.conf</code>进行配置</p>
<p>参考<a href="https://github.com/Kicamon/dotfile/blob/main/neofetch/config.conf">Kicamon</a>的配置，进行了一些修改，用<code>-</code>代替图标</p>
<h4 id="3-网易云音乐">3. 网易云音乐</h4>
<p>写文章时没点音乐怎么行，目前Arch下我认为比较好的解决方法一是<a href="https://github.com/qier222/YesPlayMusic">yesplaymusic</a>，第二个就是<a href="https://github.com/go-musicfox/go-musicfox">go-musicfox</a></p>
<p>不过yesplaymusic尝试过三种登陆方式均无法登陆，遂只能使用go-musicfox</p>
<blockquote>
<p>go-musicfox是用Go写的又一款网易云音乐命令行客户端，支持UnblockNeteaseMusic、各种音质级别、lastfm、MPRIS、MacOS交互响应（睡眠暂停、蓝牙耳机连接断开响应、菜单栏控制等）&hellip;</p>
</blockquote>
<ol>
<li>使用<code>pacman -S go-musicfox</code>安装go-musicfox</li>
<li>输入<code>musicfox</code>进入tui</li>
<li>点击-<code>我的歌单</code>进行登陆</li>
</ol>
<h5 id="31-无法播放">3.1 无法播放</h5>
<p>如果你很幸运，能直接播放，可以忽略这一步</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pacman -S pulseaudio-alsa libavtp
</span></span></code></pre></div><p>安装缺少的两个包就可以播放了</p>
<h5 id="32-快捷键">3.2 快捷键</h5>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>←</code>  <code>h</code></td>
<td>左方向</td>
</tr>
<tr>
<td><code>→</code> <code>l</code></td>
<td>右方向</td>
</tr>
<tr>
<td><code>↑</code> <code>k</code></td>
<td>上方向</td>
</tr>
<tr>
<td><code>↓</code> <code>j</code></td>
<td>下方向</td>
</tr>
<tr>
<td><code>-</code> <code>滚轮下</code></td>
<td>减小音量</td>
</tr>
<tr>
<td><code>=</code> <code>滚轮上</code></td>
<td>增大音量</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>Space</code> (空格)</td>
<td>暂停/播放</td>
</tr>
</tbody>
</table>
<p>更多快捷键请看<a href="https://github.com/go-musicfox/go-musicfox">README</a></p>
<h3 id="bash">Bash</h3>
<p>这次安装我离开了Zsh，重新回到了Bash的怀抱，但默认的Prompt太丑了，只显示最后一级路径，于是<del>抄</del>参考<a href="https://gitweb.gentoo.org/repo/gentoo.git/tree/app-shells/bash/files/bashrc/">Gentoo</a>的<code>.bashrc</code>，重新配置了下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-.bashrc" data-lang=".bashrc"><span style="display:flex;"><span><span style="color:#75715e"># /etc/bash/bashrc</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This file is sourced by all *interactive* bash shells on startup,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># including some apparently interactive shells such as scp and rcp</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># that can&#39;t tolerate any output.  So make sure this doesn&#39;t display</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># anything or bad things will happen!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Test for an interactive shell.  There is no need to set anything</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># past this point for scp and rcp, and it&#39;s important to refrain from</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># outputting anything in those cases.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> $- !<span style="color:#f92672">=</span> *i* <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Shell is non-interactive.  Be done now!</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Bash won&#39;t get SIGWINCH if another process is in the foreground.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Enable checkwinsize so that bash will check the terminal size when</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># it regains control.  #65623</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># http://cnswww.cns.cwru.edu/~chet/bash/FAQ (E11)</span>
</span></span><span style="display:flex;"><span>shopt -s checkwinsize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Disable completion when the input buffer is empty.  i.e. Hitting tab</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># and waiting a long time for bash to expand all of $PATH.</span>
</span></span><span style="display:flex;"><span>shopt -s no_empty_cmd_completion
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Enable history appending instead of overwriting when exiting.  #139609</span>
</span></span><span style="display:flex;"><span>shopt -s histappend
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Save each command to the history file as it&#39;s executed.  #517342</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This does mean sessions get interleaved when reading later on, but this</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># way the history is always up to date.  History is not synced across live</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># sessions though; that is what `history -n` does.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Disabled by default due to concerns related to system recovery when $HOME</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># is under duress, or lives somewhere flaky (like NFS).  Constantly syncing</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the history will halt the shell prompt until it&#39;s finished.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#PROMPT_COMMAND=&#39;history -a&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Change the window title of X terminals</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#e6db74">${</span>TERM<span style="color:#e6db74">}</span> in
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>aEkx<span style="color:#f92672">]</span>term* | rxvt* | gnome* | konsole* | interix | tmux*<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	PS1<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\[\033]0;\u@\h:\w\007\]&#39;</span>
</span></span><span style="display:flex;"><span>	;;
</span></span><span style="display:flex;"><span>screen*<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	PS1<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\[\033_\u@\h:\w\033\\\]&#39;</span>
</span></span><span style="display:flex;"><span>	;;
</span></span><span style="display:flex;"><span>*<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	unset PS1
</span></span><span style="display:flex;"><span>	;;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">esac</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set colorful PS1 only on colorful terminals.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dircolors --print-database uses its own built-in database</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># instead of using /etc/DIR_COLORS.  Try to use the external file</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># first to take advantage of user additions.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We run dircolors directly due to its changes in file syntax and</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># terminal name patching.</span>
</span></span><span style="display:flex;"><span>use_color<span style="color:#f92672">=</span>false
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> type -P dircolors &gt;/dev/null; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Enable colors for ls, etc.  Prefer ~/.dir_colors #64489</span>
</span></span><span style="display:flex;"><span>	LS_COLORS<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> -f ~/.dir_colors <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dircolors -b ~/.dir_colors<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[[</span> -f /etc/DIR_COLORS <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dircolors -b /etc/DIR_COLORS<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dircolors -b<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Note: We always evaluate the LS_COLORS setting even when it&#39;s the</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># default.  If it isn&#39;t set, then `ls` will only colorize by default</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># based on file attributes and ignore extensions (even the compiled</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># in defaults of dircolors). #583814</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> -n <span style="color:#e6db74">${</span>LS_COLORS:+set<span style="color:#e6db74">}</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		use_color<span style="color:#f92672">=</span>true
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Delete it if it&#39;s empty as it&#39;s useless in that case.</span>
</span></span><span style="display:flex;"><span>		unset LS_COLORS
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Some systems (e.g. BSD &amp; embedded) don&#39;t typically come with</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># dircolors so we need to hardcode some terminals in here.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#e6db74">${</span>TERM<span style="color:#e6db74">}</span> in
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">[</span>aEkx<span style="color:#f92672">]</span>term* | rxvt* | gnome* | konsole* | screen | tmux | cons25 | *color<span style="color:#f92672">)</span> use_color<span style="color:#f92672">=</span>true ;;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">esac</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#e6db74">${</span>use_color<span style="color:#e6db74">}</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">${</span>EUID<span style="color:#e6db74">}</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		PS1<span style="color:#f92672">+=</span><span style="color:#e6db74">&#39;\[\033[01;31m\]\h\[\033[01;34m\] \w \$\[\033[00m\] &#39;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		PS1<span style="color:#f92672">+=</span><span style="color:#e6db74">&#39;\[\033[01;32m\]\u@\h\[\033[01;34m\] \w \$\[\033[00m\] &#39;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#BSD#@export CLICOLOR=1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	alias ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls --color=auto&#39;</span>
</span></span><span style="display:flex;"><span>	alias grep<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;grep --colour=auto&#39;</span>
</span></span><span style="display:flex;"><span>	alias la<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -A&#39;</span>
</span></span><span style="display:flex;"><span>	alias ll<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -alF&#39;</span>
</span></span><span style="display:flex;"><span>	alias l<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -CF&#39;</span>
</span></span><span style="display:flex;"><span>	alias n<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;neofetch&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># show root@ when we don&#39;t have colors</span>
</span></span><span style="display:flex;"><span>	PS1<span style="color:#f92672">+=</span><span style="color:#e6db74">&#39;\u@\h \w \$ &#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> sh in /etc/bash/bashrc.d/*; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">[[</span> -r <span style="color:#e6db74">${</span>sh<span style="color:#e6db74">}</span> <span style="color:#f92672">]]</span> <span style="color:#f92672">&amp;&amp;</span> source <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>sh<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Try to keep environment pollution down, EPA loves us.</span>
</span></span><span style="display:flex;"><span>u
</span></span></code></pre></div><p>主要添加了别名，其他的可以自己修改</p>
<p>还有一个镰刀锤子配置也蛮好看的，但使用<code>↑</code>键查看历史命令时有Bug,不介意的可以用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-.bashrc" data-lang=".bashrc"><span style="display:flex;"><span> PS1<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;\e[1;32m\w\n\e[1;33m☭ \[</span><span style="color:#66d9ef">$(</span>tput sgr0<span style="color:#66d9ef">)</span><span style="color:#e6db74">\]&#34;</span>
</span></span></code></pre></div><p>配置来源: <a href="https://www.zhihu.com/question/19803678/answer/1001803388">https://www.zhihu.com/question/19803678/answer/1001803388</a></p>
<h4 id="sddm美化">SDDM美化</h4>
<p>我们更换壁纸后一般连同SDDM的背景一起换了，但设置里的SDDM主题管理实在是难用，经常打不开更换界面，推荐直接到主题目录下更换</p>
<ol>
<li>
<p>cd到需要配置的SDDM主题目录<code>/usr/share/sddm/themes/</code></p>
</li>
<li>
<p>进入主题文件夹，你会看见之前设置的背景(若有的话)，和两个配置文件，分别是预设配置<code>theme.conf</code>和用户配置<code>theme.conf.user</code></p>
</li>
<li>
<p>编辑用户配置<code>theme.conf.user</code>，找到<code>background=100857791_p113767970.png</code>这一行，可以看到目前我的背景为<code>100857791_p113767970.png</code></p>
</li>
<li>
<p>将要设置的背景移入主题文件夹，将<code>background=</code>后的文件名改为要设置的文件名</p>
</li>
<li>
<p>重启即可</p>
</li>
</ol>
<h2 id="内核编译">内核编译</h2>
<p>Arch下的内核编译只需要安装两个包即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pacman -S bc inetutils
</span></span></code></pre></div><p># inetutils提供hostsname</p>
<p>到这里Arch的配置也基本完成了，我也可以睡个好觉了&hellip;</p>
<p>再插一嘴，uu们有好的图床或对象储存推荐吗，博客老没图片也不行，最好能便宜点</p>
<h2 id="参考引用">参考|引用</h2>
<ul>
<li>安装Hyprland的命令来源: <a href="https://blog.ticks.cc/posts/id/37hugsk/">https://blog.ticks.cc/posts/id/37hugsk/</a></li>
</ul>
<ul>
<li>
<p>桌面介绍: <a href="https://en.wikipedia.org/">https://en.wikipedia.org/</a></p>
<p>-&gt;  <a href="https://wiki.archlinuxcn.org/wiki/KDE">https://wiki.archlinuxcn.org/wiki/KDE</a></p>
</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/LazyVim/LazyVim?tab=readme-ov-file#%EF%B8%8F-requirements">https://github.com/LazyVim/LazyVim?tab=readme-ov-file#%EF%B8%8F-requirements</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>将你的博客部署到雨云</title>
      <link>https://blog.sorgdream.com/posts/winter/</link>
      <pubDate>Fri, 17 Nov 2023 18:48:10 +0800</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/winter/</guid>
      <description><![CDATA[<h2 id="近况">近况</h2>
<p>期中考刚考完，我也难得有时间静下心来写博客，虽然文笔不太好就是了</p>
<p>这个星期，广州跳过了秋天，直接来到了冬天，也可以说广州根本就没有春天和秋天</p>
<p>看了<a href="https://arch-linux.osrc.com/">archlinux 简明指南</a>的教程，在虚拟机试了一次后为我的物理机安装上了Arch,不得不说，aur是真的好使，很多包都能在上面找到</p>
<p>每日一滚</p>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo pacman -Syu
</code></pre><p>最近半价买了一个月雨云的云服务器，学了下Nginx，把我的博客迁移到了上面</p>
<h2 id="nginx">Nginx</h2>
<p>原本想再水一篇，但想着也没什么好写的，就合并在一起</p>
<p>在你喜欢的目录创建用于存放博客的文件夹，将博客仓库<strong>git</strong>下来</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name test.inuya.ltd;
    root /home/blog;
    location / {
    }
}
</code></pre><p>跟之前一样，在服务器<code>/etc/nginx/conf.d</code>目录下创建<code>test.inuya.ltd.conf</code>配置文件，写入以上内容，这里我用二级域名<code>test.inuya.ltd</code>演示</p>
<p>在域名提供商添加<code>A类型</code>解析，填入你的IP，使用<code>http://test.inuya.ltd</code>即可访问博客</p>
<h2 id="https">https</h2>
<p>配置完，会有一个问题，就是无法通过https访问，现在很多博客的友联已经不再添加没有https的博客了</p>
<h3 id="ssl证书">ssl证书</h3>
<p><del>阿里云现有免费的一年ssl证书可以申请</del></p>
<p>阿里云证书现只有三个月有效期，遂更换cerbot自动续费</p>
<ol>
<li>在你的debian或基于debian的发行版上安装snap</li>
</ol>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo apt install snapd
</code></pre><ol start="2">
<li>安装cerbot snap包</li>
</ol>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo snap install --classic certbot
</code></pre><ol start="3">
<li>准备 Certbot 命令</li>
</ol>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo ln -s /snap 
</code></pre><ol start="4">
<li>获取证书，这里选择手动配置</li>
</ol>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo certbot certonly --nginx
</code></pre><ol start="5">
<li>测试下自动续费</li>
</ol>
<pre tabindex="0"><code class="language-command" data-lang="command">sudo certbot renew --dry-run
</code></pre><p>证书应位于<code>/etc/letsencrypt/live</code>在Nginx中填入即可</p>
<p>其他发行版也可参考<a href="https://certbot.eff.org/instructions?">certbot instructions</a>，选择对应的发行版即可</p>
<h3 id="配置">配置</h3>
<p>在原本的<code>test.inuya.ltd.conf</code>的配置中添加以下内容</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 443 ssl;
    #配置HTTPS监听端口443。
    server_name test.inuya.ltd; #将test.inuya.ltd换成证书绑定的域名
    root html;
    index index.html index.htm;
    ssl_certificate cert/test.inuya.ltd.pem;  #将test.inuya.ltd.pem换成自己的证书
    ssl_certificate_key cert/test.inuya.ltd.key; #将test.inuya.ltd换成自己的证书密钥
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    #表示使用的加密套件的类型。
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #表示使用的TLS协议的类型。
    ssl_prefer_server_ciphers on;
    location / {
        root /home/blog;  #站点目录。
        index index.html index.htm;
    }
}
</code></pre><p>使用<code>systemctl restart nginx</code>重启Nginx，尝试带https访问网址</p>
<h3 id="重定向">重定向</h3>
<p>如果想让所有的http访问都301重定向到https,可以在80端口的配置中添加一句<code>return 301 https://$server_name$request_uri;</code></p>
<p>就像这样</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name test.inuya.ltd;
    return 301 https://$server_name$request_uri;
    root /home/blog;
    location / {
    }
}
</code></pre><h2 id="主页">主页</h2>
<p>域名只解析博客太浪费了，于是搭建了我的主页</p>
<p>修改自<a href="https://github.com/noisky/Homepage">饭饭&rsquo;s Homepage 2.0</a></p>
<p>主页: <a href="https://inuya.ltd">https://inuya.ltd</a></p>
<h2 id="twikoo评论">Twikoo评论</h2>
<p>都有服务器了，还用什么valine,早就听闻twikoo配置方便，今天一用，相见恨晚</p>
<p>我是用的是docker部署，docker run时加上<code>--restart=always</code>设置自启</p>
<p>部署完后访问<code>http://&lt;ip&gt;:8080</code>，返回值如下</p>
<pre tabindex="0"><code>&#34;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/frontend.html 完成前端的配置&#34;
</code></pre><h2 id="nginx反向代理">Nginx反向代理</h2>
<p>因该是这么叫吧</p>
<p>部署到服务器后，发现评论系统被拦截了，因为博客是https，但评论只有http,所以被拦截</p>
<p>到域名服务商新建一条<code>A记录</code>解析，填入你的IP</p>
<p>在<code>/etc/nginx/conf.d</code>新建配置文件</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    listen 80;
    server_name twikoo.inuya.ltd; # 设置的域名
    return 301 https://$server_name$request_uri; # 重定向至HTTPS
    location / {
    }
}
 
server {
    listen 443 ssl;
    server_name twikoo.inuya.ltd;
    ssl_certificate cert/twikoo.inuya.ltd.pem;  # 配置证书
    ssl_certificate_key cert/twikoo.inuya.ltd.key;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    # 表示使用的加密套件的类型。
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 表示使用的TLS协议的类型。
    ssl_prefer_server_ciphers on;
    location / {
        proxy_pass  http://localhost:8080; # 反向代理至8080端口
    }
}
</code></pre><p><code>systemctl restart nginx</code>重启Nginx，尝试使用域名访问</p>
<h2 id="cdn">CDN</h2>
<p>最近博客莫名延迟变高，甚至到了无法访问的地步，于是想着给博客套个CDN加速一下;正好雨云有免费的CDN可用</p>
<p>在雨云创建一个新的CDN,如购买了雨云的产品(云服务器/虚拟主机)可以免费使用。</p>
<p>创建完后复制生成的网址到域名注册商添加<code>CNAME</code>，这里为了方便直接使用<code>*.inuya.ltd</code>泛解析</p>
<h2 id="题外话">题外话</h2>
<p>博客第一次有人主动申请友链，还是蛮激动的</p>
<p>如果有急事可以用<code>inuya@foxmail.com</code>联系我，因为是腾讯的邮箱所以可以微信提醒，回复的比较及时</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://blog.csdn.net/qq_37960603/article/details/112371339">Nginx：Nginx添加SSL实现HTTPS访问</a></li>
<li><a href="https://blog.csdn.net/HD243608836/article/details/112861186">nginx开启ssl并把http重定向到https的两种方式</a></li>
<li><a href="https://blog.csdn.net/weixin_38312502/article/details/101780412">nuxt.js项目部署到linux服务器，并使用域名访问</a></li>
<li><a href="https://www.luxiyue.com/server/%e4%b8%aa%e4%ba%ba%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8a%e9%83%a8%e7%bd%b2%e5%8d%9a%e5%ae%a2%e8%af%84%e8%ae%ba%e7%b3%bb%e7%bb%9f%ef%bc%9atwikoo/">个人服务器上部署博客评论系统：Twikoo</a></li>
<li><a href="https://blog.csdn.net/Hu_wen/article/details/110521804">Docker 容器设置自启动</a></li>
<li><a href="https://twikoo.js.org/">Twikoo文档</a></li>
<li><a href="https://certbot.eff.org/instructions?ws=nginx&amp;os=debianbuster">Certbot 说明</a></li>
</ul>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Linux下的各种shell</title>
      <link>https://blog.sorgdream.com/posts/shell/</link>
      <pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/shell/</guid>
      <description><![CDATA[<p>安装完linux要干什么？ 当然是美化一下终端啦</p>
<h2 id="fish">FIsh</h2>
<blockquote>
<p>fish is a smart and user-friendly command line shell for Linux, macOS, and the rest of the family.</p>
</blockquote>
<p>我接触到的第一个shell，自带语法高亮和自动补全这两项神器，如果你不嫌弃默认的主题的话，fish可以说是开箱即用</p>
<h3 id="安装">安装</h3>
<p>ubuntu环境下，使用<strong>apt</strong>命令进行安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt install fish
</span></span></code></pre></div><p>安装完成后直接输入<code>fish</code>即可进入，默认会有一段欢迎语，如果不喜欢，可以用<code>fish -c &quot;set -U fish_greeting&quot;</code>来关闭</p>
<p>如果想要设置为默认的shell，则需使用<code>chsh -s $(which fish)</code>进行设置</p>
<h3 id="主题">主题</h3>
<p>安装完成后当然要再装一个主题<del>除非你喜欢默认</del></p>
<p>这里我们使用<a href="https://github.com/oh-my-fish/oh-my-fish/tree/master/docs/zh-CN">oh-my-fish</a>来安装主题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -L github.com/oh-my-fish/oh-my-fish/raw/master/bin/install | fish
</span></span><span style="display:flex;"><span>omf help
</span></span></code></pre></div><p>完成后输入omf，在fish下，如果命令是绿色的，那就是安装成功了，否则检查是否安装成功</p>
<p>输入omf theme即可查看能够安装的主题，以fox主题为例，下列是omf的使用方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>omf theme  <span style="color:#75715e">#列出主题</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>omf install fox <span style="color:#75715e">#安装fox主题</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>omf theme fox  <span style="color:#75715e">#更换fox主题</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>omf doctor  <span style="color:#75715e">#自检</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>omf destroy  <span style="color:#75715e">#卸载</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>omf update <span style="color:#75715e">#更新</span>
</span></span></code></pre></div><p>如需安装更多主题请看<a href="https://xiao_beita.gitee.io/009_fish_omf/">小贝塔</a>，里面把所有的主题样式都展示出来</p>
<h3 id="别名">别名</h3>
<p>fish自带了<code>la</code>也就是<code>ls -A</code>的别名，能更方便我们查看</p>
<h2 id="zsh">Zsh</h2>
<blockquote>
<p>Zsh is a shell designed for interactive use, although it is also a powerful scripting language. Many of the useful features of bash, ksh, and tcsh were incorporated into zsh; many original features were added.</p>
</blockquote>
<p>zsh对于bash的兼容性要好很多，相对的，想要配置zsh对比fish也要难</p>
<h3 id="安装-1">安装</h3>
<p>同样，使用<strong>apt</strong>命令安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt install zsh
</span></span></code></pre></div><p>不同的是，zsh安装下一次启动终端时会弹出配置界面，使用和数字键选择即可完成配置</p>
<h3 id="主题-1">主题</h3>
<p>因为omz会拖慢zsh的速度，所以我们不选用omz来配置</p>
<p>这里以p10k主题为例;需要注意的是，因为p10k使用一部分的emoji图标，所以要想完美的显示最好安装nerd字体</p>
<blockquote>
<p>不想安装或已经安装完成的小伙伴可以跳过这一步
依据github上的文档，下载这四个字体文件，并分别双击安装，然后在终端的首选项里选择nerd字体即可</p>
</blockquote>
<p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf">MesloLGS NF Regular.ttf</a></p>
<p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf">MesloLGS NF Bold.ttf</a></p>
<p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf">MesloLGS NF 斜体.ttf</a></p>
<p><a href="https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf">MesloLGS NF Bold Italic.ttf</a></p>
<p>安装完字体就可以正式开始安装p10k主题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone --depth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;source ~/powerlevel10k/powerlevel10k.zsh-theme&#39;</span> &gt;&gt;~/.zshrc
</span></span></code></pre></div><p>使用以上命令即可完成安装
使用<code>exec zsh</code>重新启动zsh，完成后即可看到p10k的配置界面，按照提示，完成配置即可</p>
<h3 id="插件">插件</h3>
<p>因为zsh默认没有语法高亮和自动补全，所以需要两个插件来实现</p>
<h4 id="语法高亮">语法高亮</h4>
<p>使用<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a>这个插件来实现高亮</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;source </span><span style="color:#e6db74">${</span>(q-)PWD<span style="color:#e6db74">}</span><span style="color:#e6db74">/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&#34;</span> &gt;&gt; <span style="color:#e6db74">${</span>ZDOTDIR<span style="color:#66d9ef">:-</span>$HOME<span style="color:#e6db74">}</span>/.zshrc
</span></span></code></pre></div><p>使用以上两条命令安装插件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</span></span></code></pre></div><p>开启插件</p>
<h4 id="自动补全">自动补全</h4>
<p>使用[zsh-autosuggestions](git clone <a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a> ~/.zsh/zsh-autosuggestions
)这一个插件实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
</span></span></code></pre></div><p>可能有细心的小伙伴发现，对语法高亮，自动补全貌似少了一条命令，因为自动补全没有将插件<code>echo</code>到<code>.zshrc</code>配置文件中，会导致重启终端后不启动插件，需要手动执行source命令开启，而语法高亮因为<code>echo</code>到<code>.zshrc</code>中，所以会跟着zsh一同启动</p>
<p>我们可以手动添加一条命令到<code>.zshrc</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;source </span><span style="color:#e6db74">${</span>(q-)PWD<span style="color:#e6db74">}</span><span style="color:#e6db74">~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh&#34;</span> &gt;&gt; <span style="color:#e6db74">${</span>ZDOTDIR<span style="color:#66d9ef">:-</span>$HOME<span style="color:#e6db74">}</span>/.zshrc
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#                  ~/ 插件文件夹 / 插件.zsh               &gt;&gt;&gt;写入到.zshrc                    </span>
</span></span></code></pre></div><p>修改完成后执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
</span></span></code></pre></div><p>多重启几次终端，查看是否开启自动补全，如果重启没有自动补全，则需要检查上面的<code>echo</code>命令的路径是否是你插件的位置</p>
<h3 id="别名-1">别名</h3>
<p>zsh默认是没有带任何别名的，我们要去<code>.zshrc</code>中自行配置，zsh的配置文件在<code>/home/username/.zshrc</code></p>
<pre tabindex="0"><code>alias la=&#39;ls -A&#39;
alias ll=&#39;ls -alF&#39;
alias l=&#39;ls -CF&#39;
</code></pre><p>即可设置别名，也可以仿照上面的格式自定义</p>
<h2 id="bash">Bash</h2>
<blockquote>
<p>This is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and the C shell (csh)</p>
</blockquote>
<p>这是debian和众多发行版默认的shell，<del>也是作者正在用的shell</del> 用回zsh了，p10k真香</p>
<p>因为zsh和fish对bash的不兼容，使我在打包AnyKernel3的时候需要手动添加一行命令到.zshrc，以我的性格肯定不能忍，于是我就想有没有一种既对bash兼容性好，又方便易用的解决方案</p>
<h3 id="语法">语法</h3>
<p>因为脚本大多用的解释器都是bash,所以学习了下bash的语法</p>
<ul>
<li>脚本解释器</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span></code></pre></div><ul>
<li>变量</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> 
</span></span><span style="display:flex;"><span>c<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$a<span style="color:#f92672">+</span>$b<span style="color:#66d9ef">))</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo $c
</span></span></code></pre></div><p>输出结果为3</p>
<ul>
<li>环境变量
使用<strong>export</strong>命令</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export ABC<span style="color:#f92672">=</span>/usr/local/abc <span style="color:#75715e">#重启终端后失效</span>
</span></span></code></pre></div><ul>
<li>逻辑运算
<code>&amp;&amp;</code>与运算，需要同时为True</li>
</ul>
<p><code>||</code>或运算，其中一个为True</p>
<ul>
<li>if语句</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> 条件 <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        command
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span> <span style="color:#75715e">#以fi结尾</span>
</span></span></code></pre></div><ul>
<li>for语句</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> arg in <span style="color:#f92672">[</span>list<span style="color:#f92672">]</span>;<span style="color:#66d9ef">do</span> 
</span></span><span style="display:flex;"><span>    command1
</span></span><span style="display:flex;"><span>    command2
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>不要忘了do前的;</p>
<ul>
<li>while语句</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> condition <span style="color:#f92672">]</span>;<span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    command1
</span></span><span style="display:flex;"><span>    command2
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><ul>
<li>until循环</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">until</span> condition;<span style="color:#66d9ef">do</span> <span style="color:#75715e"># 条件为false则进入循环</span>
</span></span><span style="display:flex;"><span>    command1
</span></span><span style="display:flex;"><span>    command2
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><ul>
<li>函数</li>
</ul>
<p>使用<code>function</code>定义一个函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> func_name<span style="color:#f92672">(){</span> 
</span></span><span style="display:flex;"><span>    command1
</span></span><span style="display:flex;"><span>    command2
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span><span style="color:#66d9ef">return</span> value<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>可直接使用函数名调用函数，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> helloworld<span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Hello World&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>helloworld
</span></span></code></pre></div><p>将在屏幕输出<code>HelloWorld</code></p>
<ul>
<li>sed命令</li>
</ul>
<p>作用是找到并替换文本，如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sed -i <span style="color:#e6db74">&#34;s/world/hugo/g&#34;</span> helloworld.sh <span style="color:#75715e">#将helloworld.sh中的world全部替换成hugo  </span>
</span></span></code></pre></div><h3 id="starship">Starship</h3>
<ol>
<li>这是一个以兼容性优先，使用Rust编写，高度自定义的命令的提示符</li>
<li>它可以用于各种shell，包括常见的Bash/zsh/fish等，所以基本不存在兼容性问题，又能得到美丽的终端</li>
<li><del>自带自动补全和语法高亮</del> 需要shell支持，开箱即用，安装简单，对小白极其友好</li>
</ol>
<h3 id="安装-2">安装</h3>
<p>starship的安装十分简单，只需要执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -sS https://starship.rs/install.sh | sh
</span></span></code></pre></div><p>即可完成安装，之后你需要在<code>.bashrc</code>里开启starship
<!-- raw HTML omitted -->在.bashrc的最后，添加以下内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>starship init bash<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>重启终端，即可看到starship的默认样式</p>
<h3 id="进阶">进阶</h3>
<p>如果不满意默认的主题，可以使用以下命令创建配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>mkdir -p ~/.config <span style="color:#f92672">&amp;&amp;</span> touch ~/.config/starship.toml
</span></span></code></pre></div><p>修改配置请看 <a href="https://starship.rs/config/">https://starship.rs/config/</a> 预设里还能找到别人的主题配置</p>
<h3 id="ps1">PS1</h3>
<p>在用了一段时间的starship后，可能会有小伙伴发现，打开多文件的文件夹会比较卡顿，路径有时会折叠</p>
<p>于是我果断卸载，改用最简单粗暴的方式，直接修改<code>PS1</code>变量
<!-- raw HTML omitted -->PS1的含义太多了，这里就不全列出来</p>
<table>
<thead>
<tr>
<th>\u</th>
<th>用户名</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\w</td>
<td>绝对路径</td>
</tr>
<tr>
<td>\W</td>
<td>路径的最后一个文件夹</td>
</tr>
<tr>
<td>\t</td>
<td>24小时制时间</td>
</tr>
<tr>
<td>\T</td>
<td>12小时制</td>
</tr>
<tr>
<td>$</td>
<td>root用户为#,普通$</td>
</tr>
<tr>
<td>\h</td>
<td>主题名</td>
</tr>
<tr>
<td>\d</td>
<td>日期</td>
</tr>
</tbody>
</table>
<p>你也可以设置颜色</p>
<table>
<thead>
<tr>
<th>30m</th>
<th>黑色</th>
</tr>
</thead>
<tbody>
<tr>
<td>31m</td>
<td>红色</td>
</tr>
<tr>
<td>32m</td>
<td>绿色</td>
</tr>
<tr>
<td>33m</td>
<td>黄色</td>
</tr>
<tr>
<td>34m</td>
<td>蓝色</td>
</tr>
</tbody>
</table>
<p>更多变量和颜色请看</p>
<p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/html_node/Controlling-the-Prompt.html">官方文档</a></p>
<p><a href="https://blog.csdn.net/qq_33958966/article/details/106080204">CSDN</a></p>
<p>除此之外，还可以使用一些其他的符号和文字美化，例如 &gt; /~/abc/./+等都可以，也可以使用表情</p>
<p>我现在用的是CSDN里找的<a href="https://blog.csdn.net/u011145574/article/details/105160496">ParrotOS风格</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>PS1<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\[\033[0;31m\]\342\224\214\342\224\200$([[ $? != 0 ]] &amp;&amp; echo &#34;[\[\033[0;31m\]\342\234\227\[\033[0;37m\]]\342\224\200&#34;)[\[\033[0;39m\]\u\[\033[01;33m\]@\[\033[01;96m\]\h\[\033[0;31m\]]\342\224\200[\[\033[0;32m\]\w\[\033[0;31m\]]\n\[\033[0;31m\]\342\224\224\342\224\200\342\224\200\342\225\274 \[\033[0m\]\[\e[01;33m\]\$ \[\e[0m\]&#39;</span>
</span></span></code></pre></div><blockquote>
<p>ps1来自csdn@Jiuh-star，侵联删</p>
</blockquote>
<p>因为<code>$</code>和命令贴的太近，于是在 $和&quot;[\e[0m]]&ldquo;中间加了一个空格</p>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/452686607">一文掌握shell脚本的基本语法</a></p>]]></description>
      
    </item>
    
    
    
    <item>
      <title>香橙派zero3</title>
      <link>https://blog.sorgdream.com/posts/orangepi/</link>
      <pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/orangepi/</guid>
      <description><![CDATA[<h2 id="基础配置">基础配置</h2>
<table>
<thead>
<tr>
<th>CPU</th>
<th>全志H618高性能四核Cortex-A53处理器 1.5GHz</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPU</td>
<td>Mali G31 MP2</td>
</tr>
<tr>
<td>RAM</td>
<td>1GB/1.5GB/2GB/4GB LPDDR4</td>
</tr>
<tr>
<td>储存</td>
<td>16MB SPI Flash</td>
</tr>
<tr>
<td>板载WiFi+蓝牙</td>
<td>WiFi5和蓝牙5.0</td>
</tr>
<tr>
<td>网络</td>
<td>10M/100M/1000M以太网接口</td>
</tr>
<tr>
<td>音频输入、输出</td>
<td>13Pin扩展端口支持2路输出1路输入</td>
</tr>
<tr>
<td>视频输出</td>
<td>Micro HDMI支持4K@60fps</td>
</tr>
<tr>
<td>USB</td>
<td>USB 2.0 x 3（需搭配扩展版）</td>
</tr>
<tr>
<td>SD卡接口</td>
<td>Micro SD</td>
</tr>
<tr>
<td>电源输入</td>
<td>5V3A，Type-c接口</td>
</tr>
<tr>
<td>拓展接口</td>
<td>26Pin GPIO接口 &amp;&amp; 13Pin GPIO接口</td>
</tr>
</tbody>
</table>
<p>因为原本买它是用来搭建mc服务器的，所以ram选择4g版</p>
<h2 id="安装系统">安装系统</h2>
<p>开发版出场带一个微型的linxu，因为板载储存只有16m，所以仅供测试使用，我们需要刷入一个新的系统</p>
<h3 id="格式化">格式化</h3>
<p>我用的是京东京造麒麟128g的sd卡，第一次直接用balena写入镜像，插入能识别到卡但还是默认的微型Linux，所以改sd card formatter格式化之后再用win32写入，工具再官网即可下载，系统镜像也可在此下载（万恶的百度网盘）</p>
<p>BTW，买完后最好还是看一遍用户手册，写的还是比较详细的，能帮助快速入门</p>
<h3 id="刷入">刷入</h3>
<p>直接将写入系统的的sd卡怼到卡槽，重启就完事了</p>
<h3 id="登陆">登陆</h3>
<p>因为没有屏幕，所以我们需要使用ssh来远程控制，先接上网线，注意，网线的另一头要接到路由器上
<!-- raw HTML omitted -->登陆路由器后台，找到orangepi3,查看设备ip，使用<code>ssh root@ip</code>登陆
<!-- raw HTML omitted -->如果在用windows的话可以使用mobaxterm进行图形化登陆</p>
<p>如果登不上后台，可以使用<code>ifconfig</code>获取网络信息</p>
<ol>
<li>使用<code>sudo pacman -S net-tools nmap</code>安装所需包</li>
<li>执行命令后找到<code>inet 192.168.xx.xxx</code>这一行</li>
<li>使用<code>nmap 192.168.xx.0/24</code>扫描局域网下的设备</li>
<li>找到类似<code>Nmap scan report for orangepizero3 (192.168.xx.xxx)</code>就是香橙派的IP,ssh连接即可</li>
</ol>
<h2 id="系统配置">系统配置</h2>
<p>和普通的linxu一样，我们首先进行换源，作者选择<a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">清华源</a>,系统debian，其他的例如ubuntu也可以在镜像站找到
<!-- raw HTML omitted -->因为debian普通用户默认不再sudo组的，所以我们直接以root用户登陆</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>apt install vim 
</span></span></code></pre></div><p>使用<code>vim /etc/apt/sources.lis</code>修改，将源改为清华大学源
<!-- raw HTML omitted --><code>:wq</code>保存并退出修改</p>
<p>软件自带了python、zsh我们这里安装一个<code>neofetch</code>来砍下系统是否为debian</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>apt install neofetch
</span></span></code></pre></div><p>让我们来n以下</p>
<pre tabindex="0"><code>neofetch
</code></pre><p>有圈圈似的图案就说明Debian已经成功刷入了，如果图案是企鹅的话就说明我们还在默认的微型Linux</p>
<h2 id="美化">美化</h2>
<p>因为自带了zsh，所以不需要额外安装，使用<code>zsh</code>即可切换
<!-- raw HTML omitted -->使用<code>chsh -s $(which zsh)</code>即可设置默认shell</p>
<h3 id="主题">主题</h3>
<p>选用p10k主题，教程来自<a href="https://github.com/romkatv/powerlevel10k#installation">官方</a>如果慢的话可以克隆gitee镜像</p>
<h3 id="插件">插件</h3>
<p>插件依然选用<a href="https://github.com/zsh-users/zsh-syntax-highlighting">语法高亮</a>和<a href="https://github.com/zsh-users/zsh-autosuggestions">自动补全</a></p>
<p>这里要补充下，因为自动补全少了将插件添加到.zshrc文件这一步，所以导致每次关闭终端再打开就需要重新加载插件，只需要执行这下面的命令就可以将自动补全添加到zsh配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;source </span><span style="color:#e6db74">${</span>(q-)PWD<span style="color:#e6db74">}</span><span style="color:#e6db74">/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh&#34;</span> &gt;&gt; <span style="color:#e6db74">${</span>ZDOTDIR<span style="color:#66d9ef">:-</span>$HOME<span style="color:#e6db74">}</span>/.zshrc
</span></span></code></pre></div><p>如果报错了那请检查自动补全下载到哪个文件夹，然后把<code>.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</code>替换成自己插件目录里的<code>zsh-autosuggestions.zsh</code>文件的路径</p>
<p><code>${(q-)PWD}/</code>指向当前目录，请在<code>${(q-)PWD}/</code>的后面填写当前目录下插件的位置</p>
<h2 id="时区设置">时区设置</h2>
<p>因为开发板默认是UTC时间，也就是标准时间+0000，所以导致和东八区相差8小时
<!-- raw HTML omitted -->这里参考<a href="https://blog.csdn.net/yongroot/article/details/90676764?spm=1001.2014.3001.5506">CSDN</a>的文章，是我测试唯一有用的一篇</p>
<ol>
<li>使用<code>date -R</code>查看时间</li>
<li>虽然<code>tzselect</code>看上去很像一个设定时区的命令，但是它仅仅只是告诉你该怎么写TZ变量，比如北京时间就是<code>Asia/Shanghai</code>对于想更改时间的小伙伴没什么用</li>
<li>正确的做法是修改TZ变量，使用<code>export TZ= 'Asia/Shanghai'</code>命令设置时间
但是直接修改叉掉终端后又会变回原本的时间，我们需要修改<code>/etc/profile</code>文件来永久设定系统时间</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> sudo vim /etc/profile
</span></span><span style="display:flex;"><span> export  TZ<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Asia/Shanghai&#39;</span> <span style="color:#75715e">#复制</span>
</span></span><span style="display:flex;"><span> :wq <span style="color:#75715e">#退出</span>
</span></span></code></pre></div><p>这样即使重新登录也还是北京时间</p>
<h2 id="docker">Docker</h2>
<blockquote>
<p>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器</p>
</blockquote>
<p>在安装宝塔面板前，先安装docker
<!-- raw HTML omitted -->因为开发版自带安装脚本，所以具体步骤请以用户手册为准</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>enable_docker.sh
</span></span></code></pre></div><p>使用以上命令安装，完成后测试一下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker run hello-world
</span></span></code></pre></div><p>如果有输出<code>hello from docker</code>那就是成功了</p>
<h2 id="宝塔面板">宝塔面板</h2>
<p>安装完debian后，为了方便管理，选择安装宝塔面板
<!-- raw HTML omitted -->教程来自用户文档</p>
<ol>
<li>首先我们扩容tmp分区，使用命令查看<code>/tmp</code>分区大小，如果是2G，那就不需要扩容，如果小于2G，执行以下命令扩容</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>df -h | grep <span style="color:#e6db74">&#34;/tmp&#34;</span>  <span style="color:#75715e">#查看分区大小</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo sed -i <span style="color:#e6db74">&#39;s/nosuid/&amp;,size=2G/&#39;</span> /etc/fstab   <span style="color:#75715e">#扩容</span>
</span></span></code></pre></div><p>完成后<code>sudo reboot</code>重启下</p>
<ol start="2">
<li>使用<code>sudo install_bt_panel.sh</code>安装宝塔面板，需要的时间比较久，作者用了35分钟</li>
<li>安装完成后，会打印面板地址，如果你有公网ip，那么两个都可以，如果没有还是老老实实用内网地址</li>
<li>进去后会提示安装套件，不知道为什么作者需要从源码编译安装，太耗时间了所以没装完</li>
</ol>
<h2 id="minecraft开服">Minecraft开服</h2>
<p>这也是我买开发板的主要用途，首先查看能安装的Openjdk版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt search openjdk
</span></span></code></pre></div><p>我安装的版本是<code>openjdk-17-jdk</code>具体以你的输出为准</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt install openjdk-17-jdk <span style="color:#75715e">#安装</span>
</span></span></code></pre></div><p>接下来安装MCSmanager面板
什么是MCSmanager呢？</p>
<blockquote>
<p>分布式，稳定可靠，开箱即用，高扩展性，支持 Minecraft 和其他少数游戏的控制面板</p>
</blockquote>
<p>参考官方文档，使用以下命令安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>wget -qO- https://gitee.com/mcsmanager/script/raw/master/setup_cn.sh | bash
</span></span></code></pre></div><p>基础命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 先启动面板守护进程。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这是用于进程控制，终端管理的服务进程。</span>
</span></span><span style="display:flex;"><span>systemctl start mcsm-daemon.service
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 再启动面板 Web 服务。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这是用来实现支持网页访问和用户管理的服务。</span>
</span></span><span style="display:flex;"><span>systemctl start mcsm-web.service 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 重启面板命令</span>
</span></span><span style="display:flex;"><span>systemctl restart mcsm-daemon.service
</span></span><span style="display:flex;"><span>systemctl restart mcsm-web.service
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 停止面板命令</span>
</span></span><span style="display:flex;"><span>systemctl stop mcsm-web.service
</span></span><span style="display:flex;"><span>systemctl stop mcsm-daemon.service
</span></span></code></pre></div><p>启动面板后浏览器输入<code>&lt;IP&gt;:23333</code>进入面板，如果进不去的话去宝塔面板找到安装-添加端口规则，填入<code>23333</code>端口即可</p>
<p>mcs面板实例打不开也可以用此方法</p>
<h2 id="alist">AList</h2>
<p>买开发板还有一个目的就是为了搭建一个个人nas，这里以在docker内安装alist为例</p>
<ol>
<li>为了方便管理，我们先安装一个docker管理器，直接在宝塔的应用商城内搜索即可</li>
<li>使用命令安装Alist</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker run -d --restart<span style="color:#f92672">=</span>always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -e PGID<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -e UMASK<span style="color:#f92672">=</span><span style="color:#ae81ff">022</span> --name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;alist&#34;</span> xhofe/alist:latest
</span></span></code></pre></div><ol start="3">
<li>安装完成后使用<code>docker exec -it alist ./alist admin set NEW_PASSWORD</code>设定密码，<code>NEW_PASSWORD</code>改为你要设置的密码
浏览器输入<code>http://&lt;ip&gt;:5244</code>进入alist，账号默认为<code>admin</code></li>
</ol>
<h3 id="alist挂载阿里云">alist挂载阿里云</h3>
<ol>
<li>刷新令牌
<!-- raw HTML omitted -->前往 <a href="https://alist.nn.ci/tool/aliyundrive/request.html">https://alist.nn.ci/tool/aliyundrive/request.html</a> ，点击login in，登陆自己的账号即可生成令牌</li>
<li>Oauth令牌链接
<!-- raw HTML omitted -->由于原api <code>https://api.nn.ci</code>被sni阻断，导致国内无法连接，所以要添加新的api</li>
</ol>
<pre tabindex="0"><code>https://api-cf.nn.ci/alist/ali_open/token   #二选一
https://api.xhofe.top/alist/ali_open/token
</code></pre><ol start="3">
<li>云盘类型
<!-- raw HTML omitted -->这里一定要选对，如果错了会导致加载不了，登录阿里云盘手机端4.9.0以上的版本就可以看到。如果不确定可以两个都试试</li>
</ol>
<h3 id="更改密码">更改密码</h3>
<p>如果像我一样忘了密码，可以用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker exec -it alist ./alist admin set NEW_PASSWORD
</span></span></code></pre></div><p>重新设置一个密码，<code>NEW_PASSWORD</code>为你的密码</p>
<h3 id="挂载本地">挂载本地</h3>
<ol>
<li>将要挂载的文件/文件夹移至alist容器内</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> docker cp /home/image-hosting 200adb99680d:/orangepi/web
</span></span></code></pre></div><p># 200adb99680d - 容器ID</p>
<p># /home/image-hosting - 以东的文件夹或目录</p>
<p># /orangepi/web - 目标目录</p>
<p>完成后在后台添加<code>/orangepi</code>即可挂载文件/文件夹</p>
<h2 id="结尾">结尾</h2>
<p>开发板还有许多好玩的东西，比如刷openwrt作软路由，刷android tv作机顶盒等，这里只是列举除了一部分</p>]]></description>
      
    </item>
    
    
    
    <item>
      <title>KernelSU内核编译</title>
      <link>https://blog.sorgdream.com/posts/kernelsu/</link>
      <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/kernelsu/</guid>
      <description><![CDATA[<h2 id="环境搭建">环境搭建</h2>
<p>搭建编译所需的环境</p>
<h3 id="系统安装">系统安装</h3>
<p>教程基于ubuntu，你可以选择实机安装或者使用wsl2,如何安装请看<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a></p>
<blockquote>
<p>注：wsl下的文件传输需将文件移动到挂载点<code>/mnt/c</code></p>
</blockquote>
<h3 id="编译环境">编译环境</h3>
<p>使用以下命令安装所需软件包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt install -y bc bison build-essential curl flex g++-multilib gcc-multilib <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>                    git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>                    lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>                    libssl-dev libxml2 libxml2-utils lzop pngcrush schedtool <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>                    squashfs-tools xsltproc zip zlib1g-dev unzip  
</span></span></code></pre></div><h3 id="系统代理">系统代理</h3>
<p>如果你的设备能够直连Github，并且速度还不错，那你可以忽视这一步
<!-- raw HTML omitted -->我们使用clash作为代理工具</p>
<h4 id="linux">Linux</h4>
<p>请看我的另一篇文章<a href="https://blog.inuya.ltd/posts/clash/">Clash-For-Linux</a></p>
<h4 id="windows">Windows</h4>
<ol>
<li>下载<a href="https://github.com/Z-Siqi/Clash-for-Windows_Chinese/releases">Clash-For-Windows</a>(已存档)</li>
<li>都有图形化操作界面了还要我教？</li>
<li>使用以下命令设置终端代理</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>export https_proxy<span style="color:#f92672">=</span>http://127.0.0.1:7890 http_proxy<span style="color:#f92672">=</span>http://127.0.0.1:7890 all_proxy<span style="color:#f92672">=</span>socks5://127.0.0.1:7891
</span></span></code></pre></div><h2 id="源码下载">源码下载</h2>
<p>现在开始下载所需的内核源码和工具，我们最好创建一个工作目录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>mkdir -p kernel  <span style="color:#f92672">&amp;&amp;</span> cd kernel <span style="color:#75715e">#创建并进入工作目录</span>
</span></span><span style="display:flex;"><span>mkdir -p toolchains  <span style="color:#75715e">#工具链目录</span>
</span></span><span style="display:flex;"><span>mkdir -p source  <span style="color:#75715e">#内核源码目录</span>
</span></span></code></pre></div><h3 id="内核源码">内核源码</h3>
<p>如果你是小米用户，你可以试着下官方的源码，不过官方的源码可能不能成功编译，而且年久失修，大部分新机都没有公布源码，所以还是建议使用类原生的源码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>官方源码仓库
</span></span><span style="display:flex;"><span>https://github.com/MiCode/Xiaomi_Kernel_OpenSource
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果要下载的话请使用 git 命令
</span></span><span style="display:flex;"><span>git clone --depth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> https://github.com/MiCode/Xiaomi_Kernel_OpenSource -b cannon-r-oss  
</span></span></code></pre></div><p><code>cannon-r-oss</code>是作者的手机代号，需将<code>cannon-r-oss</code>换成自己源码的分支</p>
<p>类原生的话就简单多了，点击仓库右上角的<strong>code</strong>,把HTTPS的链接复制下来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone xxxxxxxxxxxx.git  <span style="color:#75715e"># xxxxxxxx.git换成自己的链接</span>
</span></span></code></pre></div><h3 id="添加kernelsu">添加KernelSU</h3>
<p>只需使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -LSs <span style="color:#e6db74">&#34;https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh&#34;</span> | bash -
</span></span></code></pre></div><p>即可将KernelSU添加到内核源码树
<!-- raw HTML omitted -->然后需要编辑你的配置文件，通常在<code>arch/arm64/configs/</code>，较新的机型也可能在<code>arch/arm64/configs/vendor/</code></p>
<p>进入文件夹，找到类似<code>设备代号_defconfig</code>的文件，比如我的代号是<strong>cannon</strong>，配置文件就是<code>cannon_defconfig</code></p>
<p>使用<strong>vim</strong>编辑配置文件，用<code>ESC+/</code>进入查找，在/后面输入你要找的内容，例如<code>/KPROBES</code>
<!-- raw HTML omitted -->如果没有开启相关的配置，需要手动添加</p>
<pre tabindex="0"><code>CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
</code></pre><h3 id="工具链下载">工具链下载</h3>
<p>作者使用zys-clang12和gcc4.9进行编译
<!-- raw HTML omitted -->因为zyc-clang需要下载压缩包并解压，所以我们先使用<strong>git</strong>下载gcc</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/LineageOS/android_prebuilts_gcc_linux-x86_arm_arm-linux-androideabi-4.9.git
</span></span></code></pre></div><p>浏览器访问</p>
<pre tabindex="0"><code>https://github.com/ZyCromerZ/Clang/releases/download/12.0.1-20230207-release/Clang-12.0.1-20230207.tar.gz
</code></pre><p>下载zyc-clang</p>
<p>下载完成后用<code>tar -zxvf xxxx.tar.gz</code>解压</p>
<p>如果觉得目录太常不方便的话，可以用<strong>mv</strong>命令重命名文件夹</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>mv &lt;原名称&gt; &lt;你想改的名称&gt;   
</span></span></code></pre></div><h2 id="编译脚本">编译脚本</h2>
<p>一般我们会用一个编译脚本设置环境变量、配置文件等
<!-- raw HTML omitted -->我的脚本是<del>抄</del>参考别人教程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>vim build.sh <span style="color:#75715e">#创建编译脚本 </span>
</span></span></code></pre></div><p>写入以下内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>starttime<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>date +<span style="color:#e6db74">&#39;%Y-%m-%d %H:%M:%S&#39;</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>export ARCH<span style="color:#f92672">=</span>arm64
</span></span><span style="display:flex;"><span>export SUBARCH<span style="color:#f92672">=</span>arm64
</span></span><span style="display:flex;"><span>make O<span style="color:#f92672">=</span>out cannon_defconfig
</span></span><span style="display:flex;"><span>              make -j8 O<span style="color:#f92672">=</span>out <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    NM<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/llvm-nm <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    OBJCOPY<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/llvm-objcopy <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    LD<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/ld.lld <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        CROSS_COMPILE<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/aarch64-linux-gnu- <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        CROSS_COMPILE_ARM32<span style="color:#f92672">=</span>~/kernel/toolchains/gcc-arm-4.9/bin/arm-linux-androideabi- <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        CC<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/clang <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        AR<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/llvm-ar <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        OBJDUMP<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/llvm-objdump <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        STRIP<span style="color:#f92672">=</span>~/kernel/toolchains/clang-12/bin/llvm-strip
</span></span><span style="display:flex;"><span>        2&gt;&amp;<span style="color:#ae81ff">1</span> | tee error.log
</span></span><span style="display:flex;"><span>endtime<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>date +<span style="color:#e6db74">&#39;%Y-%m-%d %H:%M:%S&#39;</span><span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>start_seconds<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>date --date<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; </span>$starttime<span style="color:#e6db74">&#34;</span> +%s<span style="color:#66d9ef">)</span>;
</span></span><span style="display:flex;"><span>end_seconds<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>date --date<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$endtime<span style="color:#e6db74">&#34;</span> +%s<span style="color:#66d9ef">)</span>;
</span></span><span style="display:flex;"><span>echo Start: $starttime.
</span></span><span style="display:flex;"><span>echo End: $endtime.
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Build Time: &#34;</span><span style="color:#66d9ef">$((</span>end_seconds-start_seconds<span style="color:#66d9ef">))</span><span style="color:#e6db74">&#34;s.&#34;</span>
</span></span></code></pre></div><p>需要注意的是，<code>cannon_defconfig</code>配置文件的路径已经在<code>arch/arm64/configs/</code></p>
<p>假设你的配置文件是<code>arch/arm64/configs/example_defconfig</code>那你只需要填写<code>example_defconfig</code>即可</p>
<p>但如果你的配置文件位于<code>arch/arm64/configs/vendor/example_defconfig</code>则需要填写<code>vendor/example_defconfig</code></p>
<h2 id="开始编译">开始编译</h2>
<p>用<code>chmod +x build.sh</code>添加执行权限，<code>./build.sh</code>执行编译脚本，产出在<code>out/arch/arm64/boot</code>目录</p>
<h2 id="打包内核">打包内核</h2>
<p>能来到这一步，你应该能成功编译出内核，恭喜你，接下来我们需要将它打包成boot或内核刷入</p>
<h3 id="anykernel3">AnyKernel3</h3>
<p>项目地址：https://github.com/osm0sis/AnyKernel3</p>
<p>用<strong>git</strong>下载AnyKernel3</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/osm0sis/AnyKernel3.git
</span></span></code></pre></div><p>你需要把产出的Image放到AnyKernel3的根目录，然后编辑<code>anykernel.sh</code>
<!-- raw HTML omitted -->需要改的是以下几点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kernel.string<span style="color:#f92672">=</span>KernelSU-cannon-inuyasha <span style="color:#75715e">#内核名称</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>.devicecheck<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">#设备检测，为0时关闭</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>.modules<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>.systemless<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>.cleanup<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>.cleanuponabort<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>device.name1<span style="color:#f92672">=</span>cannon  <span style="color:#75715e">#设备代号，可以设置多个</span>
</span></span><span style="display:flex;"><span>device.name2<span style="color:#f92672">=</span>cannong
</span></span><span style="display:flex;"><span>device.name3<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>device.name4<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>supported.versions<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>supported.patchlevels<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>supported.vendorpatchlevels<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>block<span style="color:#f92672">=</span>auto;   
</span></span><span style="display:flex;"><span>is_slot_device<span style="color:#f92672">=</span>auto;  
</span></span><span style="display:flex;"><span>ramdisk_compression<span style="color:#f92672">=</span>auto; 
</span></span><span style="display:flex;"><span>patch_vbmeta_flag<span style="color:#f92672">=</span>auto; 
</span></span></code></pre></div><p>配置完后使用<code>zip -r9 UPDATE-AnyKernel3.zip * -x .git README.md *placeholder</code>即可打包内核</p>
<p>如果使用zsh，可能会报错<code>not matches found</code>，只需要在<code>.zshrc</code>中添加</p>
<pre tabindex="0"><code>setopt no_nomatch
</code></pre><p>然后再<code>source ~/.zshrc</code>即可解决</p>
<h3 id="magiskboot">MagiskBoot</h3>
<p>如果你不喜欢用anykernel3，你也可以提取原版的boot.img使用编译出来的image替换原厂kernel</p>
<ol>
<li>首先到<a href="https://github.com/topjohnwu/Magisk/releases">Magisk</a>下载magisk.apk,重命名为.zip并解压</li>
<li>把解压后的<code>Magisk-v26.1/lib/arm64-v8a/libmagiskboot.so</code>文件，用 adb push 到手机</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>adb push Magisk-v26.1/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot 
</span></span></code></pre></div><p><code>Magisk-v26.1</code>需要改成下载的版本号</p>
<ol start="3">
<li>按照上面的方法把提取的boot.img和编译出的Image都push到手机</li>
<li>用<code>adb shell</code>进入adb，然后进入手机<code>/data/local/tmp</code>/目录，赋予magiskboot可执行权限<code>chmod +x magiskboot</code></li>
<li>执行<code>./magiskboot unpack boot.img</code>解包boot.img得到kernel文件</li>
<li>用<strong>Image</strong>替换<strong>kernel</strong><code>mv -f Image kernel</code></li>
<li>最后执行<code>./magiskboot repack boot.img</code>命令重新打包boot.img，得到<strong>new-boot.img</strong>，备份原厂boot后在fastboot中刷入即</li>
</ol>
<h2 id="拓展">拓展</h2>
<p>如果kprobe不正常工作，就会出现无限重启，不开机，替换boot后仍显示不支持等错误，接下来我们将手动修改源码集成ksu</p>
<p>首先让我们验证是否为kprobe的问题，</p>
<ol>
<li>首先用vim打开<code>KernelSU/kernel/ksu.c</code></li>
<li>找到<code>ksu_enable_sucompat() 和 ksu_enable_ksud()</code>这两行，使用<code>//</code>注释掉</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ksu_enable_sucompat();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ksu_enable_ksud()
</span></span></span></code></pre></div><p>就像这样</p>
<p>重新编译你的内核，看能否开机，如果能正常开机就是kprobe的问题，如果还是不能开机，检查你的源码是否适用你的系统</p>
<h3 id="修改内核源码">修改内核源码</h3>
<ol>
<li>使用这条命添加KSU</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl -LSs <span style="color:#e6db74">&#34;https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh&#34;</span> | bash -
</span></span></code></pre></div><ol start="2">
<li>因为要改的比较多，推荐去看<a href="https://kernelsu.org/zh_CN/guide/how-to-integrate-for-non-gki.html">官方文档</a>，写的比较详细</li>
</ol>
<h3 id="bugreport">BugReport</h3>
<p>如果手动集成还是失败，你可以去Github提供一个<a href="https://github.com/tiann/KernelSU/issues/new/choose">BugReport</a>给作者，在管理其设置，发送日志即可发送错误日志</p>
<h2 id="参考部分引用">参考|部分引用</h2>
<p><a href="https://kernelsu.org/zh_CN/guide/how-to-integrate-for-non-gki.html">如何为非 GKI 内核集成 KernelSU </a></p>
<p><a href="https://blog.ticks.cc/posts/id/ef0vy/">红米K40内核KernelSU编译</a></p>
<p><a href="https://zixijian.github.io/2021/01/15/008.html"> 手机端编译安卓内核</a></p>]]></description>
      
    </item>
    
    
    
    <item>
      <title>手机终端termux</title>
      <link>https://blog.sorgdream.com/posts/termux/</link>
      <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.sorgdream.com/posts/termux/</guid>
      <description><![CDATA[<h2 id="介绍">介绍</h2>
<blockquote>
<p>Termux 是一款Android 终端模拟器和 Linux 环境应用程序，无需 root 或设置即可直接运行。自动安装最小的基本系统 - 使用 APT 包管理器可以使用其他包。</p>
</blockquote>
<h2 id="安装">安装</h2>
<p>你可以在<a href="https://github.com/termux/termux-app">Github</a>和<a href="https://f-droid.org/zh_Hans/packages/com.termux/">F-Droid</a>找到安装包</p>
<p><!-- raw HTML omitted -->但我并不推荐你安装github或play商店上的termux，因为一些拓展程序是分版本的，你在github上下的用不了f-droid商店上的拓展，而play商店上的拓展是要花钱的，所以我推荐都在F-Droid上下载</p>
<h2 id="基础配置">基础配置</h2>
<p>和普通的linux一样，第一步是换源，这里我推荐清华大学的termux源，速度还是不错的</p>
<p>使用<code>pkg install vim</code>安装vim
<!-- raw HTML omitted -->vim修改<code>$PREFIX/etc/apt/sources.list</code>，删除原来的源，复制<a href="https://mirrors.tuna.tsinghua.edu.cn/help/termux/">清华源</a>里的内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pkg update
</span></span><span style="display:flex;"><span>pkg upgrade
</span></span></code></pre></div><p>更新一下</p>
<p>这里推荐一个软件<strong>neofetch</strong>，能打印硬件和系统信息到终端</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pkg install neofetch  <span style="color:#75715e">#安装</span>
</span></span><span style="display:flex;"><span>neofetch
</span></span></code></pre></div><h3 id="快捷键修改">快捷键修改</h3>
<p>默认的两排快捷键可能满足不了我们，我们可以编译<code>~/.termux/termux.properties</code>来修改</p>
<pre tabindex="0"><code>extra-keys = [ \
 [&#39;ESC&#39;,&#39;-&#39;,&#39;/&#39;,&#39;HOME&#39;,&#39;UP&#39;,&#39;END&#39;,&#39;PGUP&#39;,&#39;ENTER&#39;], \
 [&#39;QUOTE&#39;,&#39;CTRL&#39;,&#39;ALT&#39;,&#39;LEFT&#39;,&#39;DOWN&#39;,&#39;RIGHT&#39;,&#39;PGDN&#39;,&#39;BKSP&#39;] \]
</code></pre><p>这时我自己的配置</p>
<p>具体可以参考这个表格修改</p>
<table>
<thead>
<tr>
<th>CTRL</th>
<th>组合键</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEL</td>
<td>删除</td>
</tr>
<tr>
<td>UP</td>
<td>上键</td>
</tr>
<tr>
<td>QUPTE</td>
<td>双引号</td>
</tr>
<tr>
<td>LEFT</td>
<td>左键</td>
</tr>
<tr>
<td>RIGHT</td>
<td>右键</td>
</tr>
<tr>
<td>DOWN</td>
<td>下健</td>
</tr>
<tr>
<td>ENTER</td>
<td>回车</td>
</tr>
<tr>
<td>ECS</td>
<td>退出</td>
</tr>
<tr>
<td>PGUP</td>
<td>上翻页</td>
</tr>
<tr>
<td>PGDN</td>
<td>下翻页</td>
</tr>
</tbody>
</table>
<p>每个按键只能出现一次，一些其他按键如<code>&quot;</code> <code>|</code>也能添加</p>
<h2 id="美化">美化</h2>
<p>我主要使用zsh来美化终端，首先安装zsh</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pkg install zsh
</span></span></code></pre></div><p>设置默认shell</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>chsh -s zsh
</span></span></code></pre></div><h3 id="插件">插件</h3>
<p>和普通linxu一样，我主要<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a>和<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>这两个插件</p>
<p>具体请看我的另一篇文章<a href="https://inuyasha-660.github.io/2023/08/19/linux%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/">Linux终端美化</a></p>
<h3 id="终端配色">终端配色</h3>
<p>因为作者是从Github上下载安装的termux，用不了F-Droid上的拓展，而play商店上的还要花钱，所以我使用<a href="https://github.com/adi1090x/termux-style">termux-style</a>作为替代</p>
<p>使用以下命令下载并安装termux-style</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/adi1090x/termux-style
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cd termux-style
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>./install
</span></span></code></pre></div><p>安装完后使用<code>termux-style</code>即可进入设置界面，里面可以选字体和背景颜色</p>
<h3 id="启动语修改">启动语修改</h3>
<p>如果我们觉得默认的启动语不好看，可以修改<code>$PREFIX/etc/motd</code>来自定义启动语</p>
<p>可以用<a href="http://patorjk.com/software/taag">字符画生成器</a>生成一个Termux</p>
<pre tabindex="0"><code>  _______                             
 |__   __|                            
    | | ___ _ __ _ __ ___  _   ___  __
    | |/ _ \ &#39;__| &#39;_ ` _ \| | | \ \/ /
    | |  __/ |  | | | | | | |_| |&gt;  &lt; 
    |_|\___|_|  |_| |_| |_|\__,_/_/\_\
                                      
</code></pre><h2 id="开发">开发</h2>
<p>termux支持的开发环境很多，选择自己需要的即可
<!-- raw HTML omitted -->Termux自带python，所以不用安装</p>
<h3 id="编辑器">编辑器</h3>
<p>一个好的编辑器能提供舒服的开发环境，作者用的是<strong>vim</strong>,使用<code>pkg install vim</code>即可安装</p>
<p>想要配置vim，首先新建配置文件<code>vim ~/.vimrc</code>，作者只开启了语法高亮和行号显示</p>
<pre tabindex="0"><code>set nu               
syntax on             
</code></pre><h2 id="远程连接">远程连接</h2>
<p>我主要拿termux作为终端远程连接开发版和电脑</p>
<h3 id="准备">准备</h3>
<ol>
<li>linux主机，域名和公网ipv6</li>
<li>linux主机，公网ipv4</li>
</ol>
<p>先说第一种，我们需要购买一个域名，开启ipv6,使用dns和ddns动态解析域名到本级ipv6地址，即可使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ssh root@&lt;域名&gt;
</span></span></code></pre></div><p>远程连接linux主机</p>
<p>第二种就简单多了，如果你有一个公网ipv4,你可以直接使用<code>ssh root@&lt;ip&gt;</code>进行连接</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.sqlsec.com/2018/05/termux.html">Termux 高级终端安装使用配置教程</a></p>]]></description>
      
    </item>
    
    
  </channel>
</rss>
